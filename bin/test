#!/usr/bin/env bash
set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Define regex patterns to filter from output
FILTER_PATTERNS=(
    "Randomized with seed [0-9]+"
    "Line Coverage: [0-9]+\.[0-9]+% \\([0-9]+ / [0-9]+\\)"
    "Branch Coverage: [0-9]+\.[0-9]+% \\([0-9]+ / [0-9]+\\)"
    "Run options: exclude \\{screenshot: true\\}"
    "\\* Listening on http://127\\.0\\.0\\.1:[0-9]+"
    "\\* Version [0-9]+\\.[0-9]+\\.[0-9]+, codename: .*"
    "\\* Min threads: [0-9]+, max threads: [0-9]+"
    "Coverage report generated for .* to .*/coverage"
    "Finished in [0-9]+\\.[0-9]+ seconds \\(files took [0-9]+\\.[0-9]+ seconds to load\\)"
    "Capybara starting Puma"
    "⚠️  SLOW: [0-9]+\\.[0-9]+s - .*"
    "Warning: coverage data provided by Coverage \\[[0-9]+\\] exceeds number of lines in .*"
)

# Function to apply filters to a line
apply_filters() {
    local line="$1"
    for pattern in "${FILTER_PATTERNS[@]}"; do
        line=$(echo "$line" | sed -E "s|$pattern||g")
    done
    echo "$line"
}

# Function to filter output with a 3-line buffer
filter_output() {
    local buffer=()
    local line
    
    while IFS= read -r line; do
        # If buffer has 3 lines, print the oldest (filtered) and remove it
        if [ ${#buffer[@]} -eq 3 ]; then
            filtered_line=$(apply_filters "${buffer[0]}")
            if [ -n "$filtered_line" ]; then
                # If line contains only periods, print without newline
                if [[ "$filtered_line" =~ ^\.+$ ]]; then
                    echo -n "$filtered_line"
                else
                    echo "$filtered_line"
                fi
            fi
            buffer=("${buffer[@]:1}")  # Remove first element
        fi
        
        # Add new line to buffer
        buffer+=("$line")
        
        # Apply filters to all lines in buffer
        for i in "${!buffer[@]}"; do
            buffer[$i]=$(apply_filters "${buffer[$i]}")
        done
    done
    
    # Flush remaining buffer lines
    for line in "${buffer[@]}"; do
        if [ -n "$line" ]; then
            # If line contains only periods, print without newline
            if [[ "$line" =~ ^\.+$ ]]; then
                echo -n "$line"
            else
                echo "$line"
            fi
        fi
    done
}

# Check for --gems flag
gems_only=false
if [ $# -gt 0 ]; then
    if [ "$1" == "--gems" ] && [ $# -eq 1 ]; then
        gems_only=true
    else
        echo -e "${RED}❌ Error: bin/test only accepts --gems option${NC}"
        echo -e "${YELLOW}This script runs all tests in parallel.${NC}"
        echo ""
        echo -e "${YELLOW}Usage:${NC}"
        echo "  bin/test         # Run all tests (gems + main app)"
        echo "  bin/test --gems  # Run only gem tests"
        echo ""
        echo -e "${YELLOW}If you want to run specific tests, use one of these commands:${NC}"
        echo "  rspec path/to/spec.rb                    # Run a specific file"
        echo "  rspec path/to/spec.rb:42                 # Run test at line 42"
        echo "  bin/rspec-find                           # Find first failing test"
        echo "  bin/rspec-find path/to/spec              # Find failures in specific path"
        exit 1
    fi
fi

# Track overall test status
overall_result=0

# First, run tests for all gems
for gem_dir in gems/*/; do
    if [ -d "$gem_dir" ] && [ -f "${gem_dir}Gemfile" ]; then
        gem_name=$(basename "$gem_dir")
        echo -e "${BLUE}🔷 Testing gem: ${gem_name}${NC}"
        
        # Run gem tests with live filtered output
        echo ""
        if (cd "$gem_dir" && bundle exec rspec --format progress 2>&1 | filter_output | sed 's/^/  /'); then
            echo -e "${GREEN}  ✅ ${gem_name} tests passed!${NC}"
        else
            echo -e "${RED}  ❌ ${gem_name} tests failed!${NC}"
            overall_result=1
        fi
        echo ""
    fi
done

# Exit here if --gems flag was used
if [ "$gems_only" = true ]; then
    exit $overall_result
fi

# Then run main app tests
echo -e "${YELLOW}🧪 Running main app tests in parallel...${NC}"
echo ""

# Run tests with live filtered output
if bundle exec parallel_rspec spec/ 2>&1 | filter_output; then
    echo ""
    echo -e "${GREEN}✅ Main app tests passed!${NC}"
else
    echo ""
    echo -e "${RED}❌ Main app tests failed!${NC}"
    overall_result=1
fi
exit $overall_result