# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `pdf-reader` gem.
# Please instead update this file by running `bin/tapioca gem pdf-reader`.


# typed: strong
module PDF
  class Reader
    sig { returns(PDF::Reader::ObjectHash) }
    attr_reader :objects

    sig { params(input: T.any(String, Tempfile, IO, StringIO), opts: T::Hash[T.untyped, T.untyped]).void }
    def initialize(input, opts = {}); end

    sig { params(obj: T.untyped).returns(T.untyped) }
    def doc_strings_to_utf8(obj); end

    sig { params(str: String).returns(T::Boolean) }
    def has_utf16_bom?(str); end

    sig { returns(T.nilable(T::Hash[T.untyped, T.untyped])) }
    def info; end

    sig { returns(T.nilable(String)) }
    def metadata; end

    sig { params(num: Integer).returns(PDF::Reader::Page) }
    def page(num); end

    sig { returns(Integer) }
    def page_count; end

    sig { returns(T::Array[PDF::Reader::Page]) }
    def pages; end

    sig { returns(Float) }
    def pdf_version; end

    sig { params(obj: String).returns(String) }
    def pdfdoc_to_utf8(obj); end

    sig { returns(T::Hash[Symbol, T.untyped]) }
    def root; end

    sig { params(obj: String).returns(String) }
    def utf16_to_utf8(obj); end

    class << self
      sig do
        params(
          input: T.any(String, Tempfile, IO),
          opts: T::Hash[T.untyped, T.untyped],
          block: T.proc.params(arg0: PDF::Reader).void
        ).returns(T.untyped)
      end
      def open(input, opts = {}, &block); end
    end

    class AdvancedTextRunFilter
      sig { returns(T::Hash[Symbol, T.untyped]) }
      attr_reader :filter_hash

      sig { returns(T::Array[PDF::Reader::TextRun]) }
      attr_reader :text_runs

      sig { params(text_runs: T::Array[PDF::Reader::TextRun], filter_hash: T::Hash[Symbol, T.untyped]).void }
      def initialize(text_runs, filter_hash); end

      sig { params(attribute_value: T.untyped, operator: Symbol, filter_value: T.untyped).returns(T::Boolean) }
      def apply_operator(attribute_value, operator, filter_value); end

      sig do
        params(
          text_run: PDF::Reader::TextRun,
          conditions: T::Array[T::Hash[Symbol, T.untyped]]
        ).returns(T::Boolean)
      end
      def evaluate_and_filters(text_run, conditions); end

      sig do
        params(
          text_run: PDF::Reader::TextRun,
          attribute: Symbol,
          conditions: T::Hash[Symbol, T.untyped]
        ).returns(T::Boolean)
      end
      def evaluate_attribute_conditions(text_run, attribute, conditions); end

      sig { params(text_run: PDF::Reader::TextRun).returns(T::Boolean) }
      def evaluate_filter(text_run); end

      sig { params(text_run: PDF::Reader::TextRun, filter_hash: T::Hash[Symbol, T.untyped]).returns(T::Boolean) }
      def evaluate_filters(text_run, filter_hash); end

      sig do
        params(
          text_run: PDF::Reader::TextRun,
          conditions: T::Array[T::Hash[Symbol, T.untyped]]
        ).returns(T::Boolean)
      end
      def evaluate_or_filters(text_run, conditions); end

      sig { returns(T::Array[PDF::Reader::TextRun]) }
      def exclude; end

      sig { returns(T::Array[PDF::Reader::TextRun]) }
      def only; end

      class << self
        sig do
          params(
            text_runs: T::Array[PDF::Reader::TextRun],
            filter_hash: T::Hash[Symbol, T.untyped]
          ).returns(T::Array[PDF::Reader::TextRun])
        end
        def exclude(text_runs, filter_hash); end

        sig do
          params(
            text_runs: T::Array[PDF::Reader::TextRun],
            filter_hash: T::Hash[Symbol, T.untyped]
          ).returns(T::Array[PDF::Reader::TextRun])
        end
        def only(text_runs, filter_hash); end
      end

      VALID_OPERATORS = T.let(T::Array[Symbol])
    end

    class AesV2SecurityHandler
      sig { params(key: String).void }
      def initialize(key); end

      sig { params(buf: String, ref: PDF::Reader::Reference).returns(String) }
      def decrypt(buf, ref); end
    end

    class AesV3SecurityHandler
      sig { params(key: String).void }
      def initialize(key); end

      sig { params(buf: String, ref: PDF::Reader::Reference).returns(String) }
      def decrypt(buf, ref); end
    end

    class BoundingRectangleRunsFilter
      class << self
        sig do
          params(
            runs: T::Array[PDF::Reader::TextRun],
            rect: PDF::Reader::Rectangle
          ).returns(T::Array[PDF::Reader::TextRun])
        end
        def runs_within_rect(runs, rect); end
      end
    end

    class Buffer
      sig { returns(Integer) }
      attr_reader :pos

      sig { params(io: T.any(StringIO, Tempfile, IO), opts: T::Hash[Symbol, T.untyped]).void }
      def initialize(io, opts = {}); end

      sig { void }
      def check_size_is_non_zero; end

      sig { returns(T::Boolean) }
      def empty?; end

      sig { returns(Integer) }
      def find_first_xref_offset; end

      sig { returns(T::Boolean) }
      def in_content_stream?; end

      sig { void }
      def merge_indirect_reference; end

      sig { returns(T.nilable(Integer)) }
      def peek_byte; end

      sig { void }
      def prepare_hex_token; end

      sig { void }
      def prepare_inline_token; end

      sig { void }
      def prepare_literal_token; end

      sig { void }
      def prepare_regular_token; end

      sig { void }
      def prepare_tokens; end

      sig { params(bytes: Integer, opts: T::Hash[Symbol, T.untyped]).returns(T.nilable(String)) }
      def read(bytes, opts = {}); end

      sig { void }
      def reset_pos; end

      sig { void }
      def save_pos; end

      sig { returns(Symbol) }
      def state; end

      sig { returns(T.any(NilClass, String, PDF::Reader::Reference)) }
      def token; end

      CR = T.let(String)
      CRLF = T.let(String)
      DIGITS_ONLY = T.let(Regexp)
      FWD_SLASH = T.let(String)
      ID = T.let(String)
      LEFT_PAREN = T.let(String)
      LESS_THAN = T.let(String)
      LF = T.let(String)
      NULL_BYTE = T.let(String)
      STREAM = T.let(String)
      TOKEN_DELIMITER = T.let(T::Array[Integer])
      TOKEN_WHITESPACE = T.let(T::Array[String])
      TRAILING_BYTECOUNT = T.let(Integer)
      WHITE_SPACE = T.let(T::Array[String])
    end

    class CMap
      sig { returns(T.untyped) }
      attr_reader :map

      sig { params(data: String).void }
      def initialize(data); end

      sig { params(start_code: String, end_code: String, dst: String).void }
      def bfrange_type_one(start_code, end_code, dst); end

      sig { params(start_code: String, end_code: String, dst: T::Array[String]).void }
      def bfrange_type_two(start_code, end_code, dst); end

      sig { params(instructions: String).returns(PDF::Reader::Parser) }
      def build_parser(instructions); end

      sig { params(c: Integer).returns(T::Array[Integer]) }
      def decode(c); end

      sig { params(instructions: T::Array[String]).void }
      def process_bfchar_instructions(instructions); end

      sig { params(instructions: T::Array[T.any(T::Array[String], String)]).void }
      def process_bfrange_instructions(instructions); end

      sig { params(data: String, initial_mode: Symbol).void }
      def process_data(data, initial_mode = :none); end

      sig { returns(Integer) }
      def size; end

      sig { params(str: String).returns(T::Array[Integer]) }
      def str_to_int(str); end

      CMAP_KEYWORDS = T.let(T.unsafe(nil), T::Hash[String, Symbol])
    end

    class CidWidths
      sig { params(default: Numeric, array: T::Array[Numeric]).void }
      def initialize(default, array); end

      sig { params(default: Numeric, array: T::Array[Numeric]).returns(T::Hash[Numeric, Numeric]) }
      def parse_array(default, array); end

      sig { params(first: Integer, widths: T::Array[Numeric]).returns(T::Hash[Numeric, Numeric]) }
      def parse_first_form(first, widths); end

      sig { params(first: Integer, final: Integer, width: Numeric).returns(T::Hash[Numeric, Numeric]) }
      def parse_second_form(first, final, width); end
    end

    class Encoding
      sig { returns(String) }
      attr_reader :unpack

      sig { params(enc: T.untyped).void }
      def initialize(enc); end

      sig { params(str: String).returns(String) }
      def convert_to_utf8(str); end

      sig { returns(T::Hash[Integer, Integer]) }
      def default_mapping; end

      sig { returns(T::Hash[Integer, Integer]) }
      def differences; end

      sig { params(diff: T::Array[T.any(Integer, Symbol)]).returns(T::Hash[Integer, Integer]) }
      def differences=(diff); end

      sig { params(enc: T.untyped).returns(T.nilable(String)) }
      def get_mapping_file(enc); end

      sig { params(enc: T.untyped).returns(String) }
      def get_unpack(enc); end

      sig { returns(PDF::Reader::GlyphHash) }
      def glyphlist; end

      sig { params(glyph_code: Integer).returns(T::Array[Symbol]) }
      def int_to_name(glyph_code); end

      sig { params(glyph_code: Integer).returns(String) }
      def int_to_utf8_string(glyph_code); end

      sig { params(glyph_code: Integer).returns(String) }
      def internal_int_to_utf8_string(glyph_code); end

      sig { params(times: Integer).returns(String) }
      def little_boxes(times); end

      sig { params(file: String).void }
      def load_mapping(file); end

      sig { params(str: String).returns(String) }
      def to_utf8(str); end

      sig { returns(T::Boolean) }
      def utf8_conversion_impossible?; end

      CONTROL_CHARS = T.let(T.unsafe(nil), T::Array[Integer])
      UNKNOWN_CHAR = T.let(T.unsafe(nil), Integer)
    end

    class EncryptedPDFError < UnsupportedFeatureError; end

    class Error
      class << self
        sig { params(lvalue: T.untyped, rvalue: T.untyped).returns(T.untyped) }
        def assert_equal(lvalue, rvalue); end

        sig { params(lvalue: T.untyped, rvalue: T.untyped, chars: T.untyped).returns(T.untyped) }
        def str_assert(lvalue, rvalue, chars = nil); end

        sig { params(lvalue: T.untyped, rvalue: T.untyped, chars: T.untyped).returns(T.untyped) }
        def str_assert_not(lvalue, rvalue, chars = nil); end

        sig { params(object: Object, name: String).void }
        def validate_not_nil(object, name); end

        sig { params(object: Object, name: String, klass: Module).void }
        def validate_type(object, name, klass); end

        sig { params(object: Object, name: String, klass: Module).void }
        def validate_type_as_malformed(object, name, klass); end
      end
    end

    class EventPoint
      sig { returns(PDF::Reader::TextRun) }
      attr_reader :run

      sig { returns(Numeric) }
      attr_reader :x

      sig { params(x: Numeric, run: PDF::Reader::TextRun).void }
      def initialize(x, run); end

      sig { returns(T::Boolean) }
      def start?; end
    end

    module Filter
      class << self
        sig { params(name: Symbol, options: T::Hash[T.untyped, T.untyped]).returns(T.untyped) }
        def with(name, options = {}); end
      end

      class Ascii85
        sig { params(options: T::Hash[T.untyped, T.untyped]).void }
        def initialize(options = {}); end

        sig { params(data: String).returns(String) }
        def filter(data); end
      end

      class AsciiHex
        sig { params(options: T::Hash[T.untyped, T.untyped]).void }
        def initialize(options = {}); end

        sig { params(data: String).returns(String) }
        def filter(data); end
      end

      class Depredict
        sig { params(options: T::Hash[T.untyped, T.untyped]).void }
        def initialize(options = {}); end

        sig { params(data: String).returns(String) }
        def filter(data); end

        sig { params(data: T.untyped).returns(T.untyped) }
        def png_depredict(data); end

        sig { params(data: T.untyped).returns(T.untyped) }
        def tiff_depredict(data); end
      end

      class Flate
        sig { params(options: T::Hash[T.untyped, T.untyped]).void }
        def initialize(options = {}); end

        sig { params(data: String).returns(String) }
        def filter(data); end

        sig { params(data: T.untyped).returns(T.untyped) }
        def zlib_inflate(data); end

        ZLIB_AUTO_DETECT_ZLIB_OR_GZIP = 47
        ZLIB_RAW_DEFLATE = -15
      end

      class Lzw
        sig { params(options: T::Hash[T.untyped, T.untyped]).void }
        def initialize(options = {}); end

        sig { params(data: String).returns(String) }
        def filter(data); end
      end

      class Null
        sig { params(options: T::Hash[T.untyped, T.untyped]).void }
        def initialize(options = {}); end

        sig { params(data: T.untyped).returns(T.untyped) }
        def filter(data); end
      end

      class RunLength
        sig { params(options: T::Hash[T.untyped, T.untyped]).void }
        def initialize(options = {}); end

        sig { params(data: String).returns(String) }
        def filter(data); end
      end
    end

    class Font
      sig { returns(T.nilable(Symbol)) }
      attr_reader :basefont

      sig { returns(Numeric) }
      attr_reader :cid_default_width

      sig { returns(T::Array[Numeric]) }
      attr_reader :cid_widths

      sig { returns(T::Array[PDF::Reader::Font]) }
      attr_accessor :descendantfonts

      sig { returns(PDF::Reader::Encoding) }
      attr_accessor :encoding

      sig { returns(T.nilable(Integer)) }
      attr_reader :first_char

      sig { returns(T.nilable(PDF::Reader::FontDescriptor)) }
      attr_reader :font_descriptor

      sig { returns(T.nilable(Integer)) }
      attr_reader :last_char

      sig { returns(T.nilable(Symbol)) }
      attr_accessor :subtype

      sig { returns(PDF::Reader::CMap) }
      attr_accessor :tounicode

      sig { returns(T::Array[Integer]) }
      attr_reader :widths

      sig { params(ohash: PDF::Reader::ObjectHash, obj: T::Hash[Symbol, T.untyped]).void }
      def initialize(ohash, obj); end

      sig do
        returns(T.any(
            PDF::Reader::WidthCalculator::BuiltIn,
            PDF::Reader::WidthCalculator::Composite,
            PDF::Reader::WidthCalculator::TrueType,
            PDF::Reader::WidthCalculator::TypeOneOrThree,
            PDF::Reader::WidthCalculator::TypeZero,
          ))
      end
      def build_width_calculator; end

      sig { params(font_name: Symbol).returns(PDF::Reader::Encoding) }
      def default_encoding(font_name); end

      sig { params(obj: T.untyped).void }
      def extract_base_info(obj); end

      sig { params(obj: T.untyped).void }
      def extract_descendants(obj); end

      sig { params(obj: T.untyped).void }
      def extract_descriptor(obj); end

      sig { params(code_point: T.any(String, Integer)).returns(T.untyped) }
      def glyph_width(code_point); end

      sig { params(params: T.any(Integer, String, T::Array[T.untyped])).returns(String) }
      def to_utf8(params); end

      sig { params(params: T.any(Integer, String, T::Array[T.untyped])).returns(String) }
      def to_utf8_via_cmap(params); end

      sig { params(params: T.any(Integer, String, T::Array[T.untyped])).returns(String) }
      def to_utf8_via_encoding(params); end

      sig { params(data: String).returns(T::Array[T.nilable(T.any(Numeric, String))]) }
      def unpack(data); end
    end

    class FontDescriptor
      sig { returns(Numeric) }
      attr_reader :ascent

      sig { returns(Numeric) }
      attr_reader :avg_width

      sig { returns(Numeric) }
      attr_reader :cap_height

      sig { returns(Numeric) }
      attr_reader :descent

      sig { returns(T::Array[Numeric]) }
      attr_reader :font_bounding_box

      sig { returns(T.nilable(String)) }
      attr_reader :font_family

      sig { returns(Integer) }
      attr_reader :font_flags

      sig { returns(String) }
      attr_reader :font_name

      sig { returns(Symbol) }
      attr_reader :font_stretch

      sig { returns(Numeric) }
      attr_reader :font_weight

      sig { returns(T.nilable(Numeric)) }
      attr_reader :italic_angle

      sig { returns(Numeric) }
      attr_reader :leading

      sig { returns(Numeric) }
      attr_reader :max_width

      sig { returns(Numeric) }
      attr_reader :missing_width

      sig { returns(T.nilable(Numeric)) }
      attr_reader :stem_v

      sig { returns(T.nilable(Numeric)) }
      attr_reader :x_height

      sig { params(ohash: PDF::Reader::ObjectHash, fd_hash: T::Hash[T.untyped, T.untyped]).void }
      def initialize(ohash, fd_hash); end

      sig { returns(Numeric) }
      def glyph_to_pdf_scale_factor; end

      sig { params(char_code: Integer).returns(Numeric) }
      def glyph_width(char_code); end

      sig { returns(TTFunk::File) }
      def ttf_program_stream; end
    end

    class FormXObject
      sig { returns(T.untyped) }
      attr_reader :xobject

      sig { params(page: T.untyped, xobject: T.untyped, options: T.untyped).void }
      def initialize(page, xobject, options = {}); end

      sig { returns(T.untyped) }
      def cached_tokens_key; end

      sig { params(receivers: T.untyped, name: T.untyped, params: T.untyped).returns(T.untyped) }
      def callback(receivers, name, params = []); end

      sig { params(receivers: T.untyped, instructions: T.untyped).returns(T.untyped) }
      def content_stream(receivers, instructions); end

      sig { returns(T.untyped) }
      def content_stream_md5; end

      sig { returns(T.untyped) }
      def font_objects; end

      sig { returns(T.untyped) }
      def raw_content; end

      sig { returns(T.untyped) }
      def resources; end

      sig { returns(T.untyped) }
      def tokens; end

      sig { params(receivers: T.untyped).returns(T.untyped) }
      def walk(*receivers); end
    end

    class GlyphHash
      let T.unsafe(nil), T.nilable(T::Hash[Symbol, Integer])
      let T.unsafe(nil), T.nilable(T::Hash[Integer, T::Array[Symbol]])

      sig { void }
      def initialize; end

      sig { returns([T::Hash[Symbol, Integer], T::Hash[Integer, T::Array[Symbol]]]) }
      def load_adobe_glyph_mapping; end

      sig { params(name: T.nilable(Symbol)).returns(T.nilable(Integer)) }
      def name_to_unicode(name); end

      sig { params(codepoint: T.nilable(Integer)).returns(T::Array[Symbol]) }
      def unicode_to_name(codepoint); end
    end

    class InvalidObjectError < MalformedPDFError; end
    class InvalidPageError < ArgumentError; end

    class KeyBuilderV5
      sig { params(opts: T::Hash[Symbol, String]).void }
      def initialize(opts = {}); end

      sig { params(password: T.untyped).returns(T.untyped) }
      def auth_owner_pass(password); end

      sig { params(password: String).returns(T.nilable(String)) }
      def auth_owner_pass_r6(password); end

      sig { params(password: T.untyped).returns(T.untyped) }
      def auth_user_pass(password); end

      sig { params(password: String).returns(T.nilable(String)) }
      def auth_user_pass_r6(password); end

      sig { params(pass: String).returns(String) }
      def key(pass); end

      sig { params(password: String, salt: String, user_key: String).returns(String) }
      def r6_digest(password, salt, user_key = ''); end

      sig { params(str: String).returns(Integer) }
      def unpack_128bit_bigendian_int(str); end
    end

    class LZW
      class << self
        sig do
          params(
            string_table: PDF::Reader::LZW::StringTable,
            some_code: T.nilable(Integer),
            other_code: T.nilable(Integer)
          ).returns(String)
        end
        def create_new_string(string_table, some_code, other_code); end

        sig { params(data: String).returns(String) }
        def decode(data); end
      end

      class BitStream
        sig { params(data: String, bits_in_chunk: Integer).void }
        def initialize(data, bits_in_chunk); end

        sig { returns(Integer) }
        def read; end

        sig { params(bits_in_chunk: Integer).void }
        def set_bits_in_chunk(bits_in_chunk); end
      end

      CODE_CLEAR_TABLE = 256
      CODE_EOD = 257

      class StringTable
        sig { returns(Integer) }
        attr_reader :string_table_pos

        sig { void }
        def initialize; end

        sig { params(key: Integer).returns(T.nilable(String)) }
        def [](key); end

        sig { params(string: String).void }
        def add(string); end
      end
    end

    class MalformedPDFError < RuntimeError; end

    class NoTextFilter
      class << self
        sig { params(runs: T::Array[PDF::Reader::TextRun]).returns(T::Array[PDF::Reader::TextRun]) }
        def exclude_empty_strings(runs); end
      end
    end

    class NullSecurityHandler
      sig { params(buf: T.untyped, _ref: T.untyped).returns(T.untyped) }
      def decrypt(buf, _ref); end
    end

    class ObjectCache
      sig { returns(T.untyped) }
      attr_reader :hits

      sig { returns(T.untyped) }
      attr_reader :misses

      sig { params(lru_size: T.untyped).void }
      def initialize(lru_size = 1000); end

      sig { params(key: T.untyped).returns(T.untyped) }
      def [](key); end

      sig { params(key: T.untyped, value: T.untyped).returns(T.untyped) }
      def []=(key, value); end

      sig { params(obj: T.untyped).returns(T.untyped) }
      def cacheable?(obj); end

      sig { params(block: T.untyped).returns(T.untyped) }
      def each(&block); end

      sig { params(block: T.untyped).returns(T.untyped) }
      def each_key(&block); end

      sig { params(block: T.untyped).returns(T.untyped) }
      def each_value(&block); end

      sig { returns(T.untyped) }
      def empty?; end

      sig { params(key: T.untyped, local_default: T.untyped).returns(T.untyped) }
      def fetch(key, local_default = nil); end

      sig { params(value: T.untyped).returns(T.untyped) }
      def has_value?(value); end

      sig { params(key: T.untyped).returns(T.untyped) }
      def include?(key); end

      sig { returns(T.untyped) }
      def keys; end

      sig { returns(T.untyped) }
      def size; end

      sig { returns(T.untyped) }
      def to_s; end

      sig { params(key: T.untyped).returns(T.untyped) }
      def update_stats(key); end

      sig { returns(T.untyped) }
      def values; end

      CACHEABLE_TYPES = [:Catalog, :Page, :Pages]
    end

    class ObjectHash
      include Enumerable

      sig { returns(T.untyped) }
      attr_accessor :default

      sig { returns(Float) }
      attr_reader :pdf_version

      sig do
        returns(T.any(
          PDF::Reader::NullSecurityHandler,
          PDF::Reader::AesV2SecurityHandler,
          PDF::Reader::AesV3SecurityHandler,
          PDF::Reader::Rc4SecurityHandler,
      ))
      end
      attr_reader :sec_handler

      sig { returns(T::Hash[Symbol, T.untyped]) }
      attr_reader :trailer

      sig { params(input: T.any(IO, Tempfile, StringIO, String), opts: T::Hash[Symbol, T.untyped]).void }
      def initialize(input, opts = {}); end

      sig { params(key: T.any(Integer, PDF::Reader::Reference)).returns(T.untyped) }
      def [](key); end

      sig { params(ref: T.untyped, obj: T.untyped).returns(T.untyped) }
      def decrypt(ref, obj); end

      sig { params(key: T.untyped).returns(T.untyped) }
      def deref!(key); end

      sig { params(key: T.untyped).returns(T.nilable(T::Array[T.untyped])) }
      def deref_array(key); end

      sig { params(key: T.untyped).returns(T.nilable(T::Array[T.untyped])) }
      def deref_array!(key); end

      sig { params(key: T.untyped).returns(T.nilable(T::Array[Numeric])) }
      def deref_array_of_numbers(key); end

      sig { params(key: T.untyped).returns(T.nilable(T::Hash[Symbol, T.untyped])) }
      def deref_hash(key); end

      sig { params(key: T.untyped).returns(T.nilable(T::Hash[Symbol, T.untyped])) }
      def deref_hash!(key); end

      sig { params(key: T.untyped).returns(T.nilable(Integer)) }
      def deref_integer(key); end

      sig { params(key: T.untyped, seen: T.untyped).returns(T.untyped) }
      def deref_internal!(key, seen); end

      sig { params(key: T.untyped).returns(T.nilable(Symbol)) }
      def deref_name(key); end

      sig { params(key: T.untyped).returns(T.any(Symbol, T::Array[T.untyped], NilClass)) }
      def deref_name_or_array(key); end

      sig { params(key: T.untyped).returns(T.nilable(Numeric)) }
      def deref_number(key); end

      sig { params(key: T.untyped).returns(T.nilable(PDF::Reader::Stream)) }
      def deref_stream(key); end

      sig { params(key: T.untyped).returns(T.any(PDF::Reader::Stream, T::Array[T.untyped], NilClass)) }
      def deref_stream_or_array(key); end

      sig { params(key: T.untyped).returns(T.nilable(String)) }
      def deref_string(key); end

      sig { params(block: T.untyped).returns(T.untyped) }
      def each(&block); end

      sig { params(block: T.untyped).returns(T.untyped) }
      def each_key(&block); end

      sig { params(block: T.untyped).returns(T.untyped) }
      def each_value(&block); end

      sig { returns(T::Boolean) }
      def empty?; end

      sig { returns(T::Boolean) }
      def encrypted?; end

      sig { params(input: T.any(IO, Tempfile, StringIO, String)).returns(T.any(IO, Tempfile, StringIO)) }
      def extract_io_from(input); end

      sig { params(key: T.untyped, local_default: T.untyped).returns(T.untyped) }
      def fetch(key, local_default = nil); end

      sig { params(key: T.untyped).returns(T.untyped) }
      def fetch_object(key); end

      sig { params(key: T.untyped).returns(T.untyped) }
      def fetch_object_stream(key); end

      sig do
        params(
          obj: T.any(PDF::Reader::Reference, T::Hash[Symbol, T.untyped])
        ).returns(T::Array[T.any(PDF::Reader::Reference, T::Hash[Symbol, T.untyped])])
      end
      def get_page_objects(obj); end

      sig { params(check_key: T.untyped).returns(T::Boolean) }
      def has_key?(check_key); end

      sig { params(value: T.untyped).returns(T::Boolean) }
      def has_value?(value); end

      sig { returns(T::Array[PDF::Reader::Reference]) }
      def keys; end

      sig { params(offset: Integer).returns(PDF::Reader::Buffer) }
      def new_buffer(offset = 0); end

      sig { params(ref: T.any(Integer, PDF::Reader::Reference)).returns(T.nilable(Symbol)) }
      def obj_type(ref); end

      sig { params(key: T.untyped).returns(T.untyped) }
      def object(key); end

      sig { returns(T.untyped) }
      def object_streams; end

      sig { returns(T::Array[T.any(PDF::Reader::Reference, T::Hash[Symbol, T.untyped])]) }
      def page_references; end

      sig { params(input: String).returns(String) }
      def read_as_binary(input); end

      sig { returns(Float) }
      def read_version; end

      sig { returns(T::Boolean) }
      def sec_handler?; end

      sig { returns(Integer) }
      def size; end

      sig { params(ref: T.any(Integer, PDF::Reader::Reference)).returns(T::Boolean) }
      def stream?(ref); end

      sig { returns(T.untyped) }
      def to_a; end

      sig { returns(String) }
      def to_s; end

      sig { returns(T.untyped) }
      def values; end

      sig { params(ids: T.untyped).returns(T.untyped) }
      def values_at(*ids); end

      sig { returns(T.untyped) }
      def xref; end
    end

    class ObjectStream
      sig { params(stream: PDF::Reader::Stream).void }
      def initialize(stream); end

      sig do
        params(
          objid: Integer
        ).returns(T.any(PDF::Reader::Reference, PDF::Reader::Token, Numeric, String, Symbol, T::Array[T.untyped], T::Hash[T.untyped, T.untyped], NilClass))
      end
      def [](objid); end

      sig { returns(PDF::Reader::Buffer) }
      def buffer; end

      sig { returns(Integer) }
      def first; end

      sig { returns(T::Hash[Integer, Integer]) }
      def offsets; end

      sig { returns(Integer) }
      def size; end
    end

    class OverlappingRunsFilter
      class << self
        sig do
          params(
            sweep_line_status: T::Array[PDF::Reader::TextRun],
            event_point: PDF::Reader::EventPoint
          ).returns(T::Boolean)
        end
        def detect_intersection(sweep_line_status, event_point); end

        sig { params(runs: T::Array[PDF::Reader::TextRun]).returns(T::Array[PDF::Reader::TextRun]) }
        def exclude_redundant_runs(runs); end
      end

      OVERLAPPING_THRESHOLD = T.let(T.unsafe(nil), Float)
    end

    class Page
      sig { returns(T.any(PDF::Reader::ObjectCache, T::Hash[T.untyped, T.untyped])) }
      attr_reader :cache

      sig { returns(PDF::Reader::ObjectHash) }
      attr_reader :objects

      sig { returns(T::Hash[Symbol, T.untyped]) }
      attr_reader :page_object

      sig { params(objects: PDF::Reader::ObjectHash, pagenum: Integer, options: T::Hash[Symbol, T.untyped]).void }
      def initialize(objects, pagenum, options = {}); end

      sig { params(origin: T.untyped).returns(T.untyped) }
      def ancestors(origin = @page_object[:Parent]); end

      sig { returns(T::Hash[Symbol, T.untyped]) }
      def attributes; end

      sig { returns(T::Hash[Symbol, T::Array[Numeric]]) }
      def boxes; end

      sig { params(receivers: T::Array[Object], name: Symbol, params: T::Array[T.untyped]).void }
      def callback(receivers, name, params = []); end

      sig { params(receivers: T::Array[T.untyped], instructions: String).void }
      def content_stream(receivers, instructions); end

      sig { returns(Numeric) }
      def height; end

      sig { returns(String) }
      def inspect; end

      sig { returns(Integer) }
      def number; end

      sig { returns(String) }
      def orientation; end

      sig { returns(T::Array[Numeric]) }
      def origin; end

      sig { returns(T.untyped) }
      def page_with_ancestors; end

      sig { returns(String) }
      def raw_content; end

      sig { returns(T::Hash[Symbol, PDF::Reader::Rectangle]) }
      def rectangles; end

      sig { returns(PDF::Reader::Resources) }
      def resources; end

      sig { returns(T::Hash[Symbol, T.untyped]) }
      def root; end

      sig { returns(Integer) }
      def rotate; end

      sig { params(opts: T::Hash[Symbol, T.untyped]).returns(T::Array[PDF::Reader::TextRun]) }
      def runs(opts = {}); end

      sig { params(obj: T::Hash[Symbol, T.untyped]).returns(T::Hash[Symbol, T.untyped]) }
      def select_inheritable(obj); end

      sig { params(opts: T::Hash[Symbol, T.untyped]).returns(String) }
      def text(opts = {}); end

      sig { params(receivers: T.untyped).void }
      def walk(*receivers); end

      sig { returns(Numeric) }
      def width; end
    end

    class PageLayout
      sig do
        params(
          runs: T::Array[PDF::Reader::TextRun],
          mediabox: T.any(T::Array[Numeric], PDF::Reader::Rectangle)
        ).void
      end
      def initialize(runs, mediabox); end

      sig { returns(T.untyped) }
      def col_count; end

      sig { returns(T.untyped) }
      def col_multiplier; end

      sig { params(chars: T::Array[PDF::Reader::TextRun]).returns(T::Array[PDF::Reader::TextRun]) }
      def group_chars_into_runs(chars); end

      sig { params(rows: T.untyped).returns(T.untyped) }
      def interesting_rows(rows); end

      sig { params(haystack: T.untyped, needle: T.untyped, index: T.untyped).returns(T.untyped) }
      def local_string_insert(haystack, needle, index); end

      sig { params(collection: T.untyped).returns(T.untyped) }
      def mean(collection); end

      sig { params(collection: T.untyped).returns(T.untyped) }
      def median(collection); end

      sig { params(runs: T.untyped).returns(T.untyped) }
      def merge_runs(runs); end

      sig { returns(Numeric) }
      def page_height; end

      sig { returns(Numeric) }
      def page_width; end

      sig { params(mediabox: T.untyped).returns(T.untyped) }
      def process_mediabox(mediabox); end

      sig { returns(T.untyped) }
      def row_count; end

      sig { returns(T.untyped) }
      def row_multiplier; end

      sig { returns(String) }
      def to_s; end

      DEFAULT_FONT_SIZE = T.let(T.unsafe(nil), Numeric)
    end

    class PageState
      sig { params(page: T.untyped).void }
      def initialize(page); end

      sig { returns(T.untyped) }
      def begin_text_object; end

      sig { params(raw_fonts: T.untyped).returns(T.untyped) }
      def build_fonts(raw_fonts); end

      sig { returns(T.untyped) }
      def clone_state; end

      sig do
        params(
          a: T.untyped,
          b: T.untyped,
          c: T.untyped,
          d: T.untyped,
          e: T.untyped,
          f: T.untyped
        ).returns(T.untyped)
      end
      def concatenate_matrix(a, b, c, d, e, f); end

      sig { returns(T.untyped) }
      def ctm; end

      sig { params(x: T.untyped, y: T.untyped).returns(T.untyped) }
      def ctm_transform(x, y); end

      sig { returns(T.untyped) }
      def current_font; end

      sig { returns(T.untyped) }
      def end_text_object; end

      sig { params(label: T.untyped).returns(T.untyped) }
      def find_color_space(label); end

      sig { params(label: T.untyped).returns(T.untyped) }
      def find_font(label); end

      sig { params(label: T.untyped).returns(T.untyped) }
      def find_xobject(label); end

      sig { returns(T.untyped) }
      def font_size; end

      sig { returns(T.untyped) }
      def identity_matrix; end

      sig { params(label: T.untyped).returns(T.untyped) }
      def invoke_xobject(label); end

      sig { params(x: T.untyped, y: T.untyped).returns(T.untyped) }
      def move_text_position(x, y); end

      sig { params(x: T.untyped, y: T.untyped).returns(T.untyped) }
      def move_text_position_and_set_leading(x, y); end

      sig { params(str: T.untyped).returns(T.untyped) }
      def move_to_next_line_and_show_text(str); end

      sig { returns(T.untyped) }
      def move_to_start_of_next_line; end

      sig { params(w0: T.untyped, tj: T.untyped, word_boundary: T.untyped).returns(T.untyped) }
      def process_glyph_displacement(w0, tj, word_boundary); end

      sig { returns(T.untyped) }
      def restore_graphics_state; end

      sig { returns(T.untyped) }
      def save_graphics_state; end

      sig { params(char_spacing: T.untyped).returns(T.untyped) }
      def set_character_spacing(char_spacing); end

      sig { params(h_scaling: T.untyped).returns(T.untyped) }
      def set_horizontal_text_scaling(h_scaling); end

      sig { params(aw: T.untyped, ac: T.untyped, string: T.untyped).returns(T.untyped) }
      def set_spacing_next_line_show_text(aw, ac, string); end

      sig { params(label: T.untyped, size: T.untyped).returns(T.untyped) }
      def set_text_font_and_size(label, size); end

      sig { params(leading: T.untyped).returns(T.untyped) }
      def set_text_leading(leading); end

      sig do
        params(
          a: T.untyped,
          b: T.untyped,
          c: T.untyped,
          d: T.untyped,
          e: T.untyped,
          f: T.untyped
        ).returns(T.untyped)
      end
      def set_text_matrix_and_text_line_matrix(a, b, c, d, e, f); end

      sig { params(mode: T.untyped).returns(T.untyped) }
      def set_text_rendering_mode(mode); end

      sig { params(rise: T.untyped).returns(T.untyped) }
      def set_text_rise(rise); end

      sig { params(word_spacing: T.untyped).returns(T.untyped) }
      def set_word_spacing(word_spacing); end

      sig { params(params: T.untyped).returns(T.untyped) }
      def show_text_with_positioning(params); end

      sig { returns(T.untyped) }
      def stack_depth; end

      sig { returns(T.untyped) }
      def state; end

      sig { returns(T.untyped) }
      def text_rendering_matrix; end

      sig { params(x: T.untyped, y: T.untyped).returns(T.untyped) }
      def trm_transform(x, y); end

      DEFAULT_GRAPHICS_STATE = {
        :char_spacing   => 0,
        :word_spacing   => 0,
        :h_scaling      => 1.0,
        :text_leading   => 0,
        :text_font      => nil,
        :text_font_size => nil,
        :text_mode      => 0,
        :text_rise      => 0,
        :text_knockout  => 0
      }
    end

    class PageTextReceiver
      extend Forwardable

      sig { returns(T.untyped) }
      attr_reader :options

      sig { returns(T.untyped) }
      attr_reader :state

      sig { params(x: T.untyped, y: T.untyped).returns(T.untyped) }
      def apply_rotation(x, y); end

      sig { returns(T.untyped) }
      def content; end

      sig { params(string: String).void }
      def internal_show_text(string); end

      sig { params(label: T.untyped).returns(T.untyped) }
      def invoke_xobject(label); end

      sig { params(str: String).void }
      def move_to_next_line_and_show_text(str); end

      sig { params(page: T.untyped).returns(T.untyped) }
      def page=(page); end

      sig { params(opts: T::Hash[Symbol, T.untyped]).returns(T::Array[PDF::Reader::TextRun]) }
      def runs(opts = {}); end

      sig { params(aw: Numeric, ac: Numeric, string: String).void }
      def set_spacing_next_line_show_text(aw, ac, string); end

      sig { params(string: String).void }
      def show_text(string); end

      sig { params(params: T::Array[T.untyped]).void }
      def show_text_with_positioning(params); end

      SPACE = " "
    end

    class PagesStrategy
      OPERATORS = T.let(T.unsafe(nil), T::Hash[String, Symbol])
    end

    class Parser
      sig { params(buffer: PDF::Reader::Buffer, objects: T.nilable(PDF::Reader::ObjectHash)).void }
      def initialize(buffer, objects = nil); end

      sig { returns(T::Array[T.untyped]) }
      def array; end

      sig { returns(T::Hash[Symbol, T.untyped]) }
      def dictionary; end

      sig { returns(String) }
      def hex_string; end

      sig do
        params(
          id: Integer,
          gen: Integer
        ).returns(T.any(PDF::Reader::Reference, PDF::Reader::Token, PDF::Reader::Stream, Numeric, String, Symbol, T::Array[T.untyped], T::Hash[T.untyped, T.untyped], NilClass))
      end
      def object(id, gen); end

      sig do
        params(
          operators: T::Hash[T.any(String, PDF::Reader::Token), Symbol]
        ).returns(T.any(PDF::Reader::Reference, PDF::Reader::Token, Numeric, String, Symbol, T::Array[T.untyped], T::Hash[T.untyped, T.untyped], NilClass))
      end
      def parse_token(operators = {}); end

      sig { returns(Symbol) }
      def pdf_name; end

      sig { params(dict: T::Hash[Symbol, T.untyped]).returns(PDF::Reader::Stream) }
      def stream(dict); end

      sig { returns(String) }
      def string; end
    end

    class Point
      sig { params(x: Numeric, y: Numeric).void }
      def initialize(x, y); end

      sig { params(other: PDF::Reader::Point).returns(T::Boolean) }
      def ==(other); end

      sig { returns(Numeric) }
      def x; end

      sig { returns(Numeric) }
      def y; end
    end

    class PrintReceiver
      sig { returns(T.untyped) }
      attr_accessor :callbacks

      sig { void }
      def initialize; end

      sig { params(methodname: T.untyped, args: T.untyped).returns(T.untyped) }
      def method_missing(methodname, *args); end

      sig { params(meth: T.untyped).returns(T.untyped) }
      def respond_to?(meth); end
    end

    class Rc4SecurityHandler
      sig { params(key: String).void }
      def initialize(key); end

      sig { params(buf: T.untyped, ref: T.untyped).returns(T.untyped) }
      def decrypt(buf, ref); end
    end

    class Rectangle
      sig { params(x1: Numeric, y1: Numeric, x2: Numeric, y2: Numeric).void }
      def initialize(x1, y1, x2, y2); end

      sig { params(other: PDF::Reader::Rectangle).void }
      def ==(other); end

      sig { params(degrees: Integer).void }
      def apply_rotation(degrees); end

      sig { returns(PDF::Reader::Point) }
      def bottom_left; end

      sig { returns(PDF::Reader::Point) }
      def bottom_right; end

      sig { params(point: PDF::Reader::Point).void }
      def contains?(point); end

      sig { returns(Numeric) }
      def height; end

      sig { params(x1: Numeric, y1: Numeric, x2: Numeric, y2: Numeric).void }
      def set_corners(x1, y1, x2, y2); end

      sig { returns(T::Array[Numeric]) }
      def to_a; end

      sig { returns(PDF::Reader::Point) }
      def top_left; end

      sig { returns(PDF::Reader::Point) }
      def top_right; end

      sig { returns(Numeric) }
      def width; end

      class << self
        sig { params(arr: T::Array[Numeric]).returns(PDF::Reader::Rectangle) }
        def from_array(arr); end
      end
    end

    class Reference
      sig { returns(Integer) }
      attr_reader :gen

      sig { returns(Integer) }
      attr_reader :id

      sig { params(id: Integer, gen: Integer).void }
      def initialize(id, gen); end

      sig { params(obj: Object).returns(T::Boolean) }
      def ==(obj); end

      sig { returns(Integer) }
      def hash; end

      sig { returns(T::Array[PDF::Reader::Reference]) }
      def to_a; end

      sig { returns(Integer) }
      def to_i; end
    end

    class RegisterReceiver
      sig { returns(T.untyped) }
      attr_accessor :callbacks

      sig { void }
      def initialize; end

      sig { params(methodname: T.untyped).returns(T.untyped) }
      def all(methodname); end

      sig { params(methodname: T.untyped).returns(T.untyped) }
      def all_args(methodname); end

      sig { params(methodname: T.untyped).returns(T.untyped) }
      def count(methodname); end

      sig { params(methodname: T.untyped).returns(T.untyped) }
      def final_occurance_of(methodname); end

      sig { params(methodname: T.untyped).returns(T.untyped) }
      def first_occurance_of(methodname); end

      sig { params(methodname: T.untyped, args: T.untyped).returns(T.untyped) }
      def method_missing(methodname, *args); end

      sig { params(meth: T.untyped).returns(T.untyped) }
      def respond_to?(meth); end

      sig { params(methods: T.untyped).returns(T.untyped) }
      def series(*methods); end
    end

    class Resources
      sig { params(objects: PDF::Reader::ObjectHash, resources: T::Hash[T.untyped, T.untyped]).void }
      def initialize(objects, resources); end

      sig { returns(T::Hash[Symbol, T.untyped]) }
      def color_spaces; end

      sig { returns(T::Hash[Symbol, T.untyped]) }
      def fonts; end

      sig { returns(T::Hash[Symbol, T.untyped]) }
      def graphic_states; end

      sig { returns(T::Hash[Symbol, T.untyped]) }
      def patterns; end

      sig { returns(T::Array[Symbol]) }
      def procedure_sets; end

      sig { returns(T::Hash[Symbol, T.untyped]) }
      def properties; end

      sig { returns(T::Hash[Symbol, T.untyped]) }
      def shadings; end

      sig { returns(T::Hash[Symbol, PDF::Reader::Stream]) }
      def xobjects; end
    end

    class SecurityHandlerFactory
      class << self
        sig { params(encrypt: T.untyped, doc_id: T.untyped, password: T.untyped).returns(T.untyped) }
        def build(encrypt, doc_id, password); end

        sig { params(encrypt: T.untyped, doc_id: T.untyped, password: T.untyped).returns(T.untyped) }
        def build_standard_handler(encrypt, doc_id, password); end

        sig { params(encrypt: T.untyped, doc_id: T.untyped, password: T.untyped).returns(T.untyped) }
        def build_v5_handler(encrypt, doc_id, password); end

        sig { params(encrypt: T.untyped).returns(T.untyped) }
        def standard?(encrypt); end

        sig { params(encrypt: T.untyped).returns(T.untyped) }
        def standard_v5?(encrypt); end
      end
    end

    class StandardKeyBuilder
      sig { params(opts: T::Hash[Symbol, T.untyped]).void }
      def initialize(opts = {}); end

      sig { params(pass: T.untyped).returns(T.untyped) }
      def auth_owner_pass(pass); end

      sig { params(pass: T.untyped).returns(T.untyped) }
      def auth_user_pass(pass); end

      sig { params(pass: String).returns(String) }
      def key(pass); end

      sig { params(user_pass: T.untyped).returns(T.untyped) }
      def make_file_key(user_pass); end

      sig { params(p: T.untyped).returns(T.untyped) }
      def pad_pass(p = ""); end

      sig { params(buf: T.untyped, int: T.untyped).returns(T.untyped) }
      def xor_each_byte(buf, int); end

      PassPadBytes = [ 0x28, 0xbf, 0x4e, 0x5e, 0x4e, 0x75, 0x8a, 0x41,
                     0x64, 0x00, 0x4e, 0x56, 0xff, 0xfa, 0x01, 0x08,
                     0x2e, 0x2e, 0x00, 0xb6, 0xd0, 0x68, 0x3e, 0x80,
                     0x2f, 0x0c, 0xa9, 0xfe, 0x64, 0x53, 0x69, 0x7a ]
    end

    class Stream
      sig { returns(String) }
      attr_accessor :data

      sig { returns(T::Hash[Symbol, T.untyped]) }
      attr_accessor :hash

      sig { params(hash: T::Hash[Symbol, T.untyped], data: String).void }
      def initialize(hash, data); end

      sig { returns(String) }
      def unfiltered_data; end
    end

    class SynchronizedCache
      sig { void }
      def initialize; end

      sig { params(key: Object).returns(T.untyped) }
      def [](key); end

      sig { params(key: Object, value: T.nilable(Object)).returns(T.untyped) }
      def []=(key, value); end
    end

    class TextRun
      include Comparable

      sig { returns(Numeric) }
      attr_reader :font_size

      sig { returns(PDF::Reader::Point) }
      attr_reader :origin

      sig { returns(String) }
      attr_reader :text

      sig { returns(Numeric) }
      attr_reader :width

      sig { params(x: Numeric, y: Numeric, width: Numeric, font_size: Numeric, text: String).void }
      def initialize(x, y, width, font_size, text); end

      sig { params(other: PDF::Reader::TextRun).returns(PDF::Reader::TextRun) }
      def +(other); end

      sig { params(other: T.untyped).returns(T.untyped) }
      def <=>(other); end

      sig { returns(Numeric) }
      def area; end

      sig { returns(Numeric) }
      def character_count; end

      sig { returns(Numeric) }
      def endx; end

      sig { returns(Numeric) }
      def endy; end

      sig { returns(String) }
      def inspect; end

      sig { params(other_run: T.untyped).returns(T::Boolean) }
      def intersect?(other_run); end

      sig { params(other_run: T.untyped).returns(Numeric) }
      def intersection_area_percent(other_run); end

      sig { returns(Numeric) }
      def mean_character_width; end

      sig { params(other: PDF::Reader::TextRun).returns(T::Boolean) }
      def mergable?(other); end

      sig { returns(T::Range[Numeric]) }
      def mergable_range; end

      sig { returns(Numeric) }
      def x; end

      sig { returns(Numeric) }
      def y; end
    end

    class Token < String
      sig { params(val: T.untyped).void }
      def initialize(val); end
    end

    class TransformationMatrix
      sig { returns(Numeric) }
      attr_reader :a

      sig { returns(Numeric) }
      attr_reader :b

      sig { returns(Numeric) }
      attr_reader :c

      sig { returns(Numeric) }
      attr_reader :d

      sig { returns(Numeric) }
      attr_reader :e

      sig { returns(Numeric) }
      attr_reader :f

      sig { params(a: Numeric, b: Numeric, c: Numeric, d: Numeric, e: Numeric, f: Numeric).void }
      def initialize(a, b, c, d, e, f); end

      sig { params(a2: Numeric, b2: Numeric, c2: Numeric, d2: Numeric, e2: Numeric, f2: Numeric).void }
      def faster_multiply!(a2, b2, c2, d2, e2, f2); end

      sig { params(e2: Numeric).void }
      def horizontal_displacement_multiply!(e2); end

      sig { params(a2: Numeric, b2: Numeric, c2: Numeric, d2: Numeric, e2: Numeric, f2: Numeric).void }
      def horizontal_displacement_multiply_reversed!(a2, b2, c2, d2, e2, f2); end

      sig { returns(String) }
      def inspect; end

      sig do
        params(
          a: Numeric,
          b: Numeric,
          c: Numeric,
          d: Numeric,
          e: Numeric,
          f: Numeric
        ).returns(PDF::Reader::TransformationMatrix)
      end
      def multiply!(a, b, c, d, e, f); end

      sig { params(a2: Numeric, b2: Numeric, c2: Numeric, d2: Numeric, e2: Numeric, f2: Numeric).void }
      def regular_multiply!(a2, b2, c2, d2, e2, f2); end

      sig { returns(T::Array[Numeric]) }
      def to_a; end

      sig { params(a2: Numeric, b2: Numeric, c2: Numeric, d2: Numeric, e2: Numeric, f2: Numeric).void }
      def xy_scaling_multiply!(a2, b2, c2, d2, e2, f2); end

      sig { params(a2: Numeric, b2: Numeric, c2: Numeric, d2: Numeric, e2: Numeric, f2: Numeric).void }
      def xy_scaling_multiply_reversed!(a2, b2, c2, d2, e2, f2); end
    end

    class TypeCheck
      class << self
        sig { params(obj: T.untyped).returns(Integer) }
        def cast_to_int!(obj); end

        sig { params(obj: T.untyped).returns(Numeric) }
        def cast_to_numeric!(obj); end

        sig { params(obj: T.untyped).returns(T::Hash[Symbol, T.untyped]) }
        def cast_to_pdf_dict!(obj); end

        sig { params(obj: T.untyped).returns(T::Hash[Symbol, PDF::Reader::Stream]) }
        def cast_to_pdf_dict_with_stream_values!(obj); end

        sig { params(string: T.untyped).returns(String) }
        def cast_to_string!(string); end

        sig { params(obj: T.untyped).returns(T.nilable(Symbol)) }
        def cast_to_symbol(obj); end

        sig { params(obj: T.untyped).returns(Symbol) }
        def cast_to_symbol!(obj); end
      end
    end

    class UnimplementedSecurityHandler
      sig { params(buf: T.untyped, ref: T.untyped).returns(T.untyped) }
      def decrypt(buf, ref); end

      class << self
        sig { params(encrypt: T.untyped).returns(T.untyped) }
        def supports?(encrypt); end
      end
    end

    class UnsupportedFeatureError < RuntimeError; end

    class ValidatingReceiver
      sig { params(wrapped: T.untyped).void }
      def initialize(wrapped); end

      sig { params(args: T.untyped).void }
      def begin_inline_image(*args); end

      sig { params(args: T.untyped).void }
      def begin_inline_image_data(*args); end

      sig { params(args: T.untyped).void }
      def begin_text_object(*args); end

      sig { params(methodname: T.untyped, args: T.untyped).void }
      def call_wrapped(methodname, *args); end

      sig { params(args: T.untyped).void }
      def concatenate_matrix(*args); end

      sig { params(args: T.untyped).void }
      def end_inline_image(*args); end

      sig { params(args: T.untyped).void }
      def end_text_object(*args); end

      sig { params(args: T.untyped).void }
      def invoke_xobject(*args); end

      sig { params(methodname: Symbol, args: T.untyped).void }
      def method_missing(methodname, *args); end

      sig { params(args: T.untyped).void }
      def move_text_position(*args); end

      sig { params(args: T.untyped).void }
      def move_text_position_and_set_leading(*args); end

      sig { params(args: T.untyped).void }
      def move_to_next_line_and_show_text(*args); end

      sig { params(args: T.untyped).void }
      def move_to_start_of_next_line(*args); end

      sig { params(page: PDF::Reader::Page).void }
      def page=(page); end

      sig { params(meth: T.untyped).returns(T::Boolean) }
      def respond_to?(meth); end

      sig { params(args: T.untyped).void }
      def restore_graphics_state(*args); end

      sig { params(args: T.untyped).void }
      def save_graphics_state(*args); end

      sig { params(args: T.untyped).void }
      def set_character_spacing(*args); end

      sig { params(args: T.untyped).void }
      def set_horizontal_text_scaling(*args); end

      sig { params(args: T.untyped).void }
      def set_spacing_next_line_show_text(*args); end

      sig { params(args: T.untyped).void }
      def set_text_font_and_size(*args); end

      sig { params(args: T.untyped).void }
      def set_text_leading(*args); end

      sig { params(args: T.untyped).void }
      def set_text_matrix_and_text_line_matrix(*args); end

      sig { params(args: T.untyped).void }
      def set_text_rendering_mode(*args); end

      sig { params(args: T.untyped).void }
      def set_text_rise(*args); end

      sig { params(args: T.untyped).void }
      def set_word_spacing(*args); end

      sig { params(args: T.untyped).void }
      def show_text(*args); end

      sig { params(args: T.untyped).void }
      def show_text_with_positioning(*args); end
    end

    module WidthCalculator
      class BuiltIn
        let T.unsafe(nil), T.nilable(PDF::Reader::SynchronizedCache)

        sig { params(font: PDF::Reader::Font).void }
        def initialize(font); end

        sig { params(code_point: Integer).returns(T::Boolean) }
        def control_character?(code_point); end

        sig { params(font_name: T.nilable(Symbol)).returns(String) }
        def extract_basefont(font_name); end

        sig { params(code_point: T.nilable(Integer)).returns(Numeric) }
        def glyph_width(code_point); end

        BUILTINS = T.let(T.unsafe(nil), T::Array[Symbol])
      end

      class Composite
        sig { params(font: PDF::Reader::Font).void }
        def initialize(font); end

        sig { params(code_point: T.nilable(Integer)).returns(Numeric) }
        def glyph_width(code_point); end
      end

      class TrueType
        sig { params(font: PDF::Reader::Font).void }
        def initialize(font); end

        sig { params(code_point: T.nilable(Integer)).returns(Numeric) }
        def glyph_width(code_point); end

        sig { params(code_point: Integer).returns(T.nilable(Numeric)) }
        def glyph_width_from_descriptor(code_point); end

        sig { params(code_point: Integer).returns(T.nilable(Numeric)) }
        def glyph_width_from_font(code_point); end
      end

      class TypeOneOrThree
        sig { params(font: PDF::Reader::Font).void }
        def initialize(font); end

        sig { params(code_point: T.nilable(Integer)).returns(Numeric) }
        def glyph_width(code_point); end
      end

      class TypeZero
        sig { params(font: PDF::Reader::Font).void }
        def initialize(font); end

        sig { params(code_point: T.nilable(Integer)).returns(Numeric) }
        def glyph_width(code_point); end
      end
    end

    class XRef
      include Enumerable

      # Provides `type_member` helper
      extend T::Generic

      sig { returns(T::Hash[Symbol, T.untyped]) }
      attr_reader :trailer

      sig { params(io: T.any(IO, Tempfile, StringIO)).void }
      def initialize(io); end

      sig { params(ref: T.untyped).returns(T.untyped) }
      def [](ref); end

      sig { params(io: T.untyped).returns(T.untyped) }
      def calc_junk_offset(io); end

      sig { params(block: T.untyped).returns(T.untyped) }
      def each(&block); end

      sig { params(offset: T.untyped).returns(T.untyped) }
      def load_offsets(offset = nil); end

      sig { params(stream: T.untyped).returns(T.untyped) }
      def load_xref_stream(stream); end

      sig { params(buf: T.untyped).returns(T.untyped) }
      def load_xref_table(buf); end

      sig { params(offset: T.untyped).returns(T.untyped) }
      def new_buffer(offset = 0); end

      sig { returns(T.untyped) }
      def size; end

      sig { params(id: T.untyped, gen: T.untyped, offset: T.untyped).returns(T.untyped) }
      def store(id, gen, offset); end

      sig { params(bytes: T.untyped).returns(T.untyped) }
      def unpack_bytes(bytes); end
    end

    class ZeroWidthRunsFilter
      class << self
        sig { params(runs: T::Array[PDF::Reader::TextRun]).returns(T::Array[PDF::Reader::TextRun]) }
        def exclude_zero_width_runs(runs); end
      end
    end
  end
end
